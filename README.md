# ECE 369 MIPS32 SAD assembly code
This repository contains the MIPS32 assembly code for my Sum of Absolute (SAD) Differences algorithm. I wrote it for the Computer Architecture course ECE 369 at the University of Arizona. It can run on any MIPS32 emulator or processor, but was originally written for [my Xilinx MIPS32 processor](https://github.com/Aymane-Aeris-El-Asslouj/ECE369_MIPS32_Xilinx_processor) that I made for the same class. The SAD algorithm takes a large and a small 8-bit grey scale images and tries to superimpose the smaller one on top of the larger one such that the SAD of their pixels are minimized. This is used in video compression to identify moving objects and transmit only the object's movements as opposed to the new raw image.

## File Structure
The [Python implementation](SAD.py), [C implementation](SAD.c), and [assembly implementation](SAD.s) are all provided. The Python implementation is meant for quick testing while the C implementation is closer to assembly. The C code is written wih each line matching an assembly instruction from the assembly implementation so the assembly can be debugged mostly by running the C code. An [pintermediate pseudo-code version](SAD.txt) between the C and assembly code is also provided to highlight the mapping between the two. An [assembly test file](test.s) is also provided to the assembly implementation with various inputs and expected outputs so it can be tested using a MIPS32 emulator or processor.

## Algorithm
The SAD algorithm takes the smaller image and moves across the larger image. At each superposition, it computes the sum of absolute differences between the pixels of the small image and of the part of the larger image that is covered. It keeps track of the minimum SAD it computed along with the superposition coordinate that match it and updates them as it computes more SADs. At the end, it provides the coordinates of the minimum SAD superposition.

The Call block is the main loop containing a double nested loop to compute the SAD of the two images along with functions to move in each direction. This algorithm implementation follows a spiral pattern required by the course assingment repeating the right-down-left-up sequence until all possible superpositions have been tried. Each variable in the C code corresponds to a register with some used for multiple puposes called dummy_#.
